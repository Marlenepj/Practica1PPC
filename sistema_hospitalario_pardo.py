# -*- coding: utf-8 -*-
"""sistema_hospitalario_Pardo.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1bT6p_-5xlfUPAYnzz-twIz76SzYaoKZ0

**SIMULACIÓN DE UN SISTEMA HOSPITALARIO**

Se está realizando el proceso que se sigue en un hospital con 3 doctores, 5 camas disponibles y el cual recibe 20 pacientes en el turno. Para ello se utilizan los conceptos vistos en la clase de PPyC.
"""

import threading
import multiprocessing
import random
import time
from queue import PriorityQueue
from concurrent.futures import ThreadPoolExecutor

# Diagnósticos y estados
diagnosticos_posibles = [
    "Gripe leve", "Infección respiratoria", "Fractura de brazo", "Apendicitis",
    "COVID-19", "Hipertensión", "Diabetes no controlada",
    "Traumatismo craneoencefálico", "Inconsciente", "Requiere más estudios"
]

doc_doctores = ["Dra. Helena Hernández", "Dr. Roberto Robles", "Dra. Lilia López"]
sem_registro = threading.Semaphore(3)  # puestos de recepción
mutex_camas = threading.Lock()
camas_disponibles = 5  # número de camas disponible en el hospital
cola_turnos = PriorityQueue()

# Pool de procesos global para diagnóstico ligero
pool = multiprocessing.Pool(processes=2)

def funcion_diagnostico(paciente_id):
    riesgo = random.random()
    diagnostico = random.choice(diagnosticos_posibles)
    print(f"Paciente {paciente_id}: diagnóstico -> {diagnostico}, riesgo: {riesgo:.2f}")
    return diagnostico, riesgo

# Ejecuta diagnóstico en paralelo
def diagnostico_intensivo(id_paciente):
    return pool.apply(funcion_diagnostico, args=(id_paciente,))

# Determinar estado según diagnóstico y riesgo
def obtener_estado(diagnostico, riesgo):
    if diagnostico == "Inconsciente":
        return "crítico"
    if diagnostico == "Traumatismo craneoencefálico":
        return "grave"
    if diagnostico == "COVID-19":
        return random.choice(["grave"]*3 + ["crítico"])
    if diagnostico == "Fractura de brazo":
        return "grave"
    if diagnostico == "Requiere más estudios":
        return random.choice(["leve", "moderado", "grave", "crítico"])
    if riesgo > 0.8:
        return "crítico"
    if riesgo > 0.6:
        return "grave"
    if riesgo > 0.4:
        return "moderado"
    return "leve"

# Registro en recepción
def registrar_paciente(id_paciente):
    with sem_registro:
        print(f"Paciente {id_paciente}: registrándose en recepción...")
        time.sleep(random.uniform(0.3, 0.6))
        print(f"Paciente {id_paciente}: registro completado")

# Encolar paciente con prioridad
def encolar_paciente(id_paciente):
    diagnostico, riesgo = diagnostico_intensivo(id_paciente)
    estado = obtener_estado(diagnostico, riesgo)
    if diagnostico == "Requiere más estudios":
        cita = time.strftime("%Y-%m-%d", time.localtime(time.time() + 86400 * random.randint(1,7)))
        print(f"Paciente {id_paciente}: cita de seguimiento para {cita}")
    prioridad = 0 if estado in ("grave", "crítico") else 1
    cola_turnos.put((prioridad, id_paciente, diagnostico, riesgo, estado))
    print(f"Paciente {id_paciente}: encolado con estado '{estado}' (prioridad={prioridad})")

# Atención de pacientes por doctor
def atender_pacientes(doctor):
    global camas_disponibles
    while True:
        prioridad, id_paciente, diagnostico, riesgo, estado = cola_turnos.get()
        if id_paciente is None:
            cola_turnos.task_done()
            break
        print(f"{doctor}: atendiendo paciente {id_paciente} -> {diagnostico} (estado: {estado})")
        time.sleep(random.uniform(0.8, 1.2))
        if estado in ("grave", "crítico"):
            with mutex_camas:
                if camas_disponibles > 0:
                    camas_disponibles -= 1
                    print(f"Paciente {id_paciente}: asignada cama (restantes: {camas_disponibles})")
                else:
                    # No hay camas disponibles
                    if diagnostico == "Fractura de brazo":
                        decision = random.choice(["esperar cama", "transferencia"])
                        print(f"Paciente {id_paciente}: sin camas disponibles. Decide {decision}")
                        if decision == "transferencia":
                            print(f"Paciente {id_paciente}: solicitando ambulancia y transfiriendo a otro hospital")
                    else:
                        print(f"Paciente {id_paciente}: sin camas disponibles. Solicitando ambulancia y transfiriendo")
            print(f"Paciente {id_paciente}: en observación intensa o en traslado")
        elif diagnostico == "Requiere más estudios":
            print(f"Paciente {id_paciente}: alta temporal, esperar estudios")
        else:
            print(f"Paciente {id_paciente}: medicación administrada, alta")
        print(f"{doctor}: finalizó paciente {id_paciente}\n")
        cola_turnos.task_done()

# Flujo de cada paciente
def proceso_paciente(id_paciente):
    registrar_paciente(id_paciente)
    encolar_paciente(id_paciente)

if __name__ == "__main__":
    pacientes = range(1, 21)
    inicio = time.time()
    # Iniciar hilos de doctores
    hilos_doctores = []
    for doc in doc_doctores:
        t = threading.Thread(target=atender_pacientes, args=(doc,))
        t.start()
        hilos_doctores.append(t)

    # Registrar y encolar todos los pacientes
    with ThreadPoolExecutor(max_workers=5) as executor:
        executor.map(proceso_paciente, pacientes)

    # Enviar sentinelas para terminar a doctores
    for _ in doc_doctores:
        cola_turnos.put((2, None, None, None, None))

    cola_turnos.join()

    # Esperar a que terminen los hilos de doctores
    for t in hilos_doctores:
        t.join()
    fin = time.time()
    print(f"\nSimulación completada en {fin - inicio:.2f} segundos")